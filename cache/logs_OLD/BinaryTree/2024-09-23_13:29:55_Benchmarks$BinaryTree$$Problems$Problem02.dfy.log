2024-09-23 13:29:56.3540 INFO Initial heuristic value is 0
2024-09-23 13:29:56.3564 INFO Expanding method sequence  -- estimated distance to start = 0, distance to end = 0
2024-09-23 13:29:56.4046 TRACE Verifying the body of the following method:
static method synthesized(formal_1_1_0: int, formal_1_1_1: int, formal_1_1_2: int, formal_2_3_0: int, argument_1_0_0: BinaryTree?, argument_1_0_1: BinaryTree?, argument_1_0_2: int) returns (receiver: BinaryTree) {assume true && (if argument_1_0_0 == null then {} else argument_1_0_0.Repr) * (if argument_1_0_1 == null then {} else argument_1_0_1.Repr) == {} && (argument_1_0_0 == null || argument_1_0_0.IsValid()) && (argument_1_0_1 == null || argument_1_0_1.IsValid());
receiver := new BinaryTree(argument_1_0_0, argument_1_0_1, argument_1_0_2);
assert {:keepAssertion} !(receiver.IsValid() && receiver.View == [0, 1, 2] && receiver.Height == 1);}
2024-09-23 13:29:56.4046 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_1_1_0: int, formal_1_1_1: int, formal_1_1_2: int, formal_2_3_0: int, argument_1_0_0: BinaryTree?, argument_1_0_1: BinaryTree?, argument_1_0_2: int)
        returns (receiver: BinaryTree)
    {
      assume true && (if argument_1_0_0 == null then {} else argument_1_0_0.Repr) * (if argument_1_0_1 == null then {} else argument_1_0_1.Repr) == {} && (argument_1_0_0 == null || argument_1_0_0.IsValid()) && (argument_1_0_1 == null || argument_1_0_1.IsValid());
      receiver := new BinaryTree(argument_1_0_0, argument_1_0_1, argument_1_0_2);
      assume {:formal} formal_1_1_0 == 0;
      assume {:formal} formal_1_1_1 == 1;
      assume {:formal} formal_1_1_2 == 2;
      assume {:formal} formal_2_3_0 == 1;
      assert {:keepAssertion} !(receiver.IsValid() && receiver.View == [formal_1_1_0, formal_1_1_1, formal_1_1_2] && receiver.Height == formal_2_3_0);
    }
2024-09-23 13:29:57.6503 TRACE Verifying the body of the following method:
static method synthesized(formal_1_1_0: int, formal_1_1_1: int, formal_1_1_2: int, formal_2_3_0: int, argument_1_0_0: BinaryTree?, argument_1_0_1: BinaryTree?, argument_1_0_2: int, formal_3_15_0: int, formal_6_19_0: int, formal_7_21_0: int, formal_8_23_0: int, formal_9_25_0: int, formal_9_25_1: int, formal_7_34_0: int, formal_9_37_0: int, formal_9_37_1: int, formal_0_7_0: int) returns (receiver: BinaryTree) {assume {:attribute 10} !(argument_1_0_0 == null);
assume {:attribute 10} argument_1_0_0 in argument_1_0_0.Repr;
assume {:attribute 10} argument_1_0_0.Repr == {argument_1_0_0};
assume {:attribute 10} |argument_1_0_0.View| > 0;
assume {:attribute 10} null == argument_1_0_0.left;
assume {:attribute 10} null == argument_1_0_0.right;
assume {:attribute 10} 0 == argument_1_0_0.Height;
assume {:attribute 10} 0 == argument_1_0_0.value;
assume {:attribute 10} 1 == |argument_1_0_0.View|;
assume {:attribute 10} 0 == argument_1_0_0.View[0];
assume {:attribute 11} !(argument_1_0_1 == null);
assume {:attribute 11} argument_1_0_1 in argument_1_0_1.Repr;
assume {:attribute 11} argument_1_0_1.Repr == {argument_1_0_1};
assume {:attribute 11} |argument_1_0_1.View| > 0;
assume {:attribute 11} null == argument_1_0_1.left;
assume {:attribute 11} null == argument_1_0_1.right;
assume {:attribute 11} 0 == argument_1_0_1.Height;
assume {:attribute 11} 2 == argument_1_0_1.value;
assume {:attribute 11} 1 == |argument_1_0_1.View|;
assume {:attribute 11} 2 == argument_1_0_1.View[0];
assume true && (if argument_1_0_0 == null then {} else argument_1_0_0.Repr) * (if argument_1_0_1 == null then {} else argument_1_0_1.Repr) == {} && (argument_1_0_0 == null || argument_1_0_0.IsValid()) && (argument_1_0_1 == null || argument_1_0_1.IsValid());
receiver := new BinaryTree(argument_1_0_0, argument_1_0_1, 1);
assert {:keepAssertion} receiver.IsValid() && receiver.View == [0, 1, 2] && receiver.Height == 1;}
2024-09-23 13:29:57.6507 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_1_1_0: int, formal_1_1_1: int, formal_1_1_2: int, formal_2_3_0: int, argument_1_0_0: BinaryTree?, argument_1_0_1: BinaryTree?, argument_1_0_2: int, formal_3_15_0: int, formal_6_19_0: int, formal_7_21_0: int, formal_8_23_0: int, formal_9_25_0: int, formal_9_25_1: int, formal_7_34_0: int, formal_9_37_0: int, formal_9_37_1: int, formal_0_7_0: int)
        returns (receiver: BinaryTree)
    {
      assume {:formal} formal_3_15_0 == 0;
      assume {:formal} formal_6_19_0 == 0;
      assume {:formal} formal_7_21_0 == 0;
      assume {:formal} formal_8_23_0 == 1;
      assume {:formal} formal_9_25_0 == 0;
      assume {:formal} formal_9_25_1 == 0;
      assume {:attribute 10} !(argument_1_0_0 == null);
      assume {:attribute 10} argument_1_0_0 in argument_1_0_0.Repr;
      assume {:attribute 10} argument_1_0_0.Repr == {argument_1_0_0};
      assume {:attribute 10} |argument_1_0_0.View| > formal_3_15_0;
      assume {:attribute 10} null == argument_1_0_0.left;
      assume {:attribute 10} null == argument_1_0_0.right;
      assume {:attribute 10} formal_6_19_0 == argument_1_0_0.Height;
      assume {:attribute 10} formal_7_21_0 == argument_1_0_0.value;
      assume {:attribute 10} formal_8_23_0 == |argument_1_0_0.View|;
      assume {:attribute 10} formal_9_25_0 == argument_1_0_0.View[formal_9_25_1];
      assume {:formal} formal_7_34_0 == 2;
      assume {:formal} formal_9_37_0 == 2;
      assume {:formal} formal_9_37_1 == 0;
      assume {:attribute 11} !(argument_1_0_1 == null);
      assume {:attribute 11} argument_1_0_1 in argument_1_0_1.Repr;
      assume {:attribute 11} argument_1_0_1.Repr == {argument_1_0_1};
      assume {:attribute 11} |argument_1_0_1.View| > formal_3_15_0;
      assume {:attribute 11} null == argument_1_0_1.left;
      assume {:attribute 11} null == argument_1_0_1.right;
      assume {:attribute 11} formal_6_19_0 == argument_1_0_1.Height;
      assume {:attribute 11} formal_7_34_0 == argument_1_0_1.value;
      assume {:attribute 11} formal_8_23_0 == |argument_1_0_1.View|;
      assume {:attribute 11} formal_9_37_0 == argument_1_0_1.View[formal_9_37_1];
      assume {:formal} formal_0_7_0 == 1;
      assume {:attribute 12} argument_1_0_2 == formal_0_7_0;
      assume true && (if argument_1_0_0 == null then {} else argument_1_0_0.Repr) * (if argument_1_0_1 == null then {} else argument_1_0_1.Repr) == {} && (argument_1_0_0 == null || argument_1_0_0.IsValid()) && (argument_1_0_1 == null || argument_1_0_1.IsValid());
      receiver := new BinaryTree(argument_1_0_0, argument_1_0_1, argument_1_0_2);
      assume {:formal} formal_1_1_0 == 0;
      assume {:formal} formal_1_1_1 == 1;
      assume {:formal} formal_1_1_2 == 2;
      assume {:formal} formal_2_3_0 == 1;
      assert {:keepAssertion} receiver.IsValid() && receiver.View == [formal_1_1_0, formal_1_1_1, formal_1_1_2] && receiver.Height == formal_2_3_0;
    }
2024-09-23 13:29:57.9441 INFO Have found the following solution to a subproblem!
{
assume {:attribute 10} !(argument_1_0_0 == null);
assume {:attribute 10} argument_1_0_0 in argument_1_0_0.Repr;
assume {:attribute 10} argument_1_0_0.Repr == {argument_1_0_0};
assume {:attribute 10} |argument_1_0_0.View| > 0;
assume {:attribute 10} null == argument_1_0_0.left;
assume {:attribute 10} null == argument_1_0_0.right;
assume {:attribute 10} 0 == argument_1_0_0.Height;
assume {:attribute 10} 0 == argument_1_0_0.value;
assume {:attribute 10} 1 == |argument_1_0_0.View|;
assume {:attribute 10} 0 == argument_1_0_0.View[0];
assume {:attribute 11} !(argument_1_0_1 == null);
assume {:attribute 11} argument_1_0_1 in argument_1_0_1.Repr;
assume {:attribute 11} argument_1_0_1.Repr == {argument_1_0_1};

********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
****************** SKIPPING 25 LINES OF LOGS TO SAVE DISK SPACE ****************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************

      assume {:formal} formal_3_15_0 == 0;
      assume {:formal} formal_6_19_0 == 0;
      assume {:formal} formal_7_21_0 == 0;
      assume {:formal} formal_8_23_0 == 1;
      assume {:formal} formal_9_25_0 == 0;
      assume {:formal} formal_9_25_1 == 0;
      assert {:keepAssertion} !(!(receiver == null) && receiver in receiver.Repr && receiver.Repr == {receiver} && |receiver.View| > formal_3_15_0 && null == receiver.left && null == receiver.right && formal_6_19_0 == receiver.Height && formal_7_21_0 == receiver.value && formal_8_23_0 == |receiver.View| && formal_9_25_0 == receiver.View[formal_9_25_1]);
    }
2024-09-23 13:29:58.2906 TRACE Verifying the body of the following method:
static method synthesized(formal_3_15_0: int, formal_6_19_0: int, formal_7_21_0: int, formal_8_23_0: int, formal_9_25_0: int, formal_9_25_1: int, argument_2_0_0: BinaryTree?, argument_2_0_1: BinaryTree?, argument_2_0_2: int, formal_0_5_0: int) returns (receiver: BinaryTree) {assume true && (if null == null then {} else null.Repr) * (if null == null then {} else null.Repr) == {} && (null == null || null.IsValid()) && (null == null || null.IsValid());
receiver := new BinaryTree(null, null, 0);
assert {:keepAssertion} !(receiver == null) && receiver in receiver.Repr && receiver.Repr == {receiver} && |receiver.View| > 0 && null == receiver.left && null == receiver.right && 0 == receiver.Height && 0 == receiver.value && 1 == |receiver.View| && 0 == receiver.View[0];}
2024-09-23 13:29:58.2906 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_3_15_0: int, formal_6_19_0: int, formal_7_21_0: int, formal_8_23_0: int, formal_9_25_0: int, formal_9_25_1: int, argument_2_0_0: BinaryTree?, argument_2_0_1: BinaryTree?, argument_2_0_2: int, formal_0_5_0: int)
        returns (receiver: BinaryTree)
    {
      assume {:attribute 24} argument_2_0_0 == null;
      assume {:attribute 25} argument_2_0_1 == null;
      assume {:formal} formal_0_5_0 == 0;
      assume {:attribute 26} argument_2_0_2 == formal_0_5_0;
      assume true && (if argument_2_0_0 == null then {} else argument_2_0_0.Repr) * (if argument_2_0_1 == null then {} else argument_2_0_1.Repr) == {} && (argument_2_0_0 == null || argument_2_0_0.IsValid()) && (argument_2_0_1 == null || argument_2_0_1.IsValid());
      receiver := new BinaryTree(argument_2_0_0, argument_2_0_1, argument_2_0_2);
      assume {:formal} formal_3_15_0 == 0;
      assume {:formal} formal_6_19_0 == 0;
      assume {:formal} formal_7_21_0 == 0;
      assume {:formal} formal_8_23_0 == 1;
      assume {:formal} formal_9_25_0 == 0;
      assume {:formal} formal_9_25_1 == 0;
      assert {:keepAssertion} !(receiver == null) && receiver in receiver.Repr && receiver.Repr == {receiver} && |receiver.View| > formal_3_15_0 && null == receiver.left && null == receiver.right && formal_6_19_0 == receiver.Height && formal_7_21_0 == receiver.value && formal_8_23_0 == |receiver.View| && formal_9_25_0 == receiver.View[formal_9_25_1];
    }
2024-09-23 13:29:58.5704 INFO Have found the following solution to a subproblem!
{
argument_1_0_0 := new BinaryTree(null, null, 0);
}
2024-09-23 13:29:58.5707 INFO Time spend on subproblem: 00:00:00.6218575
2024-09-23 13:29:58.5707 INFO Number of Regular queries to Dafny used to solve subproblem: 2 (00:00:00.6204023)
2024-09-23 13:29:58.5707 INFO Number of Simplify queries to Dafny used to solve subproblem: 0 (00:00:00)
2024-09-23 13:29:58.5707 INFO Number of Heuristic queries to Dafny used to solve subproblem: 0 (00:00:00)
2024-09-23 13:29:58.5707 INFO Initial heuristic value is 0
2024-09-23 13:29:58.5707 INFO Expanding method sequence  -- estimated distance to start = 0, distance to end = 0
2024-09-23 13:29:58.5747 TRACE Verifying the body of the following method:
static method synthesized(formal_3_15_0: int, formal_6_19_0: int, formal_7_34_0: int, formal_8_23_0: int, formal_9_37_0: int, formal_9_37_1: int, argument_3_0_0: BinaryTree?, argument_3_0_1: BinaryTree?, argument_3_0_2: int) returns (receiver: BinaryTree) {assume true && (if argument_3_0_0 == null then {} else argument_3_0_0.Repr) * (if argument_3_0_1 == null then {} else argument_3_0_1.Repr) == {} && (argument_3_0_0 == null || argument_3_0_0.IsValid()) && (argument_3_0_1 == null || argument_3_0_1.IsValid());
receiver := new BinaryTree(argument_3_0_0, argument_3_0_1, argument_3_0_2);
assert {:keepAssertion} !(!(receiver == null) && receiver in receiver.Repr && receiver.Repr == {receiver} && |receiver.View| > 0 && null == receiver.left && null == receiver.right && 0 == receiver.Height && 2 == receiver.value && 1 == |receiver.View| && 2 == receiver.View[0]);}
2024-09-23 13:29:58.5747 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_3_15_0: int, formal_6_19_0: int, formal_7_34_0: int, formal_8_23_0: int, formal_9_37_0: int, formal_9_37_1: int, argument_3_0_0: BinaryTree?, argument_3_0_1: BinaryTree?, argument_3_0_2: int)
        returns (receiver: BinaryTree)
    {
      assume true && (if argument_3_0_0 == null then {} else argument_3_0_0.Repr) * (if argument_3_0_1 == null then {} else argument_3_0_1.Repr) == {} && (argument_3_0_0 == null || argument_3_0_0.IsValid()) && (argument_3_0_1 == null || argument_3_0_1.IsValid());
      receiver := new BinaryTree(argument_3_0_0, argument_3_0_1, argument_3_0_2);
      assume {:formal} formal_3_15_0 == 0;
      assume {:formal} formal_6_19_0 == 0;
      assume {:formal} formal_7_34_0 == 2;
      assume {:formal} formal_8_23_0 == 1;
      assume {:formal} formal_9_37_0 == 2;
      assume {:formal} formal_9_37_1 == 0;
      assert {:keepAssertion} !(!(receiver == null) && receiver in receiver.Repr && receiver.Repr == {receiver} && |receiver.View| > formal_3_15_0 && null == receiver.left && null == receiver.right && formal_6_19_0 == receiver.Height && formal_7_34_0 == receiver.value && formal_8_23_0 == |receiver.View| && formal_9_37_0 == receiver.View[formal_9_37_1]);
    }
2024-09-23 13:29:58.9071 TRACE Verifying the body of the following method:
static method synthesized(formal_3_15_0: int, formal_6_19_0: int, formal_7_34_0: int, formal_8_23_0: int, formal_9_37_0: int, formal_9_37_1: int, argument_3_0_0: BinaryTree?, argument_3_0_1: BinaryTree?, argument_3_0_2: int, formal_0_9_0: int) returns (receiver: BinaryTree) {assume true && (if null == null then {} else null.Repr) * (if null == null then {} else null.Repr) == {} && (null == null || null.IsValid()) && (null == null || null.IsValid());
receiver := new BinaryTree(null, null, 2);
assert {:keepAssertion} !(receiver == null) && receiver in receiver.Repr && receiver.Repr == {receiver} && |receiver.View| > 0 && null == receiver.left && null == receiver.right && 0 == receiver.Height && 2 == receiver.value && 1 == |receiver.View| && 2 == receiver.View[0];}
2024-09-23 13:29:58.9071 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_3_15_0: int, formal_6_19_0: int, formal_7_34_0: int, formal_8_23_0: int, formal_9_37_0: int, formal_9_37_1: int, argument_3_0_0: BinaryTree?, argument_3_0_1: BinaryTree?, argument_3_0_2: int, formal_0_9_0: int)
        returns (receiver: BinaryTree)
    {
      assume {:attribute 38} argument_3_0_0 == null;
      assume {:attribute 39} argument_3_0_1 == null;
      assume {:formal} formal_0_9_0 == 2;
      assume {:attribute 40} argument_3_0_2 == formal_0_9_0;
      assume true && (if argument_3_0_0 == null then {} else argument_3_0_0.Repr) * (if argument_3_0_1 == null then {} else argument_3_0_1.Repr) == {} && (argument_3_0_0 == null || argument_3_0_0.IsValid()) && (argument_3_0_1 == null || argument_3_0_1.IsValid());
      receiver := new BinaryTree(argument_3_0_0, argument_3_0_1, argument_3_0_2);
      assume {:formal} formal_3_15_0 == 0;
      assume {:formal} formal_6_19_0 == 0;
      assume {:formal} formal_7_34_0 == 2;
      assume {:formal} formal_8_23_0 == 1;
      assume {:formal} formal_9_37_0 == 2;
      assume {:formal} formal_9_37_1 == 0;
      assert {:keepAssertion} !(receiver == null) && receiver in receiver.Repr && receiver.Repr == {receiver} && |receiver.View| > formal_3_15_0 && null == receiver.left && null == receiver.right && formal_6_19_0 == receiver.Height && formal_7_34_0 == receiver.value && formal_8_23_0 == |receiver.View| && formal_9_37_0 == receiver.View[formal_9_37_1];
    }
2024-09-23 13:29:59.1756 INFO Have found the following solution to a subproblem!
{
argument_1_0_1 := new BinaryTree(null, null, 2);
}
2024-09-23 13:29:59.1756 INFO Time spend on subproblem: 00:00:00.6040912
2024-09-23 13:29:59.1756 INFO Number of Regular queries to Dafny used to solve subproblem: 2 (00:00:00.6023736)
2024-09-23 13:29:59.1756 INFO Number of Simplify queries to Dafny used to solve subproblem: 0 (00:00:00)
2024-09-23 13:29:59.1756 INFO Number of Heuristic queries to Dafny used to solve subproblem: 0 (00:00:00)
2024-09-23 13:29:59.1756 INFO Have found the following solution!
static method solution() returns (result:BinaryTree)
ensures Goal(result)
{
var argument_1_0_0 := new BinaryTree(null, null, 0);
var argument_1_0_1 := new BinaryTree(null, null, 2);
result := new BinaryTree(argument_1_0_0, argument_1_0_1, 1);
}
2024-09-23 13:29:59.1756 INFO Total time spend on synthesis: 00:00:02.9435626
2024-09-23 13:29:59.1756 INFO Total number of Regular queries to Dafny: 6 (00:00:02.7657505)
2024-09-23 13:29:59.1756 INFO Total number of Simplify queries to Dafny: 0 (00:00:00)
2024-09-23 13:29:59.1756 INFO Total number of Heuristic queries to Dafny: 0 (00:00:00)
