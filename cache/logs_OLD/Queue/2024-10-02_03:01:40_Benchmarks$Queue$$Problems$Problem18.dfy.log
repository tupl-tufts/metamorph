2024-10-02 03:01:41.3872 DEBUG Using integer programming to estimating the distance to this.View() == [0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18], receiver.IsValid()
2024-10-02 03:01:41.4031 TRACE Minimizing value: ((((Rotate + IsEmpty) + Enqueue) + Front) + Dequeue)
2024-10-02 03:01:41.4031 DEBUG The integer programming gives the lower bound of 0 methods.
2024-10-02 03:01:41.4066 DEBUG In particular, need at least -0 calls to Rotate
2024-10-02 03:01:41.4066 DEBUG In particular, need at least -0 calls to IsEmpty
2024-10-02 03:01:41.4066 DEBUG In particular, need at least -0 calls to Enqueue
2024-10-02 03:01:41.4066 DEBUG In particular, need at least -0 calls to Front
2024-10-02 03:01:41.4066 DEBUG In particular, need at least -0 calls to Dequeue
2024-10-02 03:01:41.4066 INFO Initial heuristic value is 0
2024-10-02 03:01:41.4066 INFO Expanding method sequence  -- estimated distance to start = 0, distance to end = 0
2024-10-02 03:01:41.4483 TRACE Verifying the body of the following method:
static method synthesized(formal_1_1492_0: int, formal_1_1492_1: int, formal_1_1492_2: int, formal_1_1492_3: int, formal_1_1492_4: int, formal_1_1492_5: int, formal_1_1492_6: int, formal_1_1492_7: int, formal_1_1492_8: int, formal_1_1492_9: int, formal_1_1492_10: int, formal_1_1492_11: int, formal_1_1492_12: int, formal_1_1492_13: int, formal_1_1492_14: int, formal_1_1492_15: int, formal_1_1492_16: int, formal_1_1492_17: int) returns (receiver: Queue) {assume true;
receiver := new Queue();
assert {:keepAssertion} !(receiver.IsValid() && receiver.View() == [0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]);}
2024-10-02 03:01:41.4483 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_1_1492_0: int, formal_1_1492_1: int, formal_1_1492_2: int, formal_1_1492_3: int, formal_1_1492_4: int, formal_1_1492_5: int, formal_1_1492_6: int, formal_1_1492_7: int, formal_1_1492_8: int, formal_1_1492_9: int, formal_1_1492_10: int, formal_1_1492_11: int, formal_1_1492_12: int, formal_1_1492_13: int, formal_1_1492_14: int, formal_1_1492_15: int, formal_1_1492_16: int, formal_1_1492_17: int)
        returns (receiver: Queue)
    {
      assume true;
      receiver := new Queue();
      assume {:formal} formal_1_1492_0 == 0;
      assume {:formal} formal_1_1492_1 == 1;
      assume {:formal} formal_1_1492_2 == 2;
      assume {:formal} formal_1_1492_3 == 4;
      assume {:formal} formal_1_1492_4 == 5;
      assume {:formal} formal_1_1492_5 == 6;
      assume {:formal} formal_1_1492_6 == 7;
      assume {:formal} formal_1_1492_7 == 8;
      assume {:formal} formal_1_1492_8 == 9;
      assume {:formal} formal_1_1492_9 == 10;
      assume {:formal} formal_1_1492_10 == 11;
      assume {:formal} formal_1_1492_11 == 12;
      assume {:formal} formal_1_1492_12 == 13;
      assume {:formal} formal_1_1492_13 == 14;
      assume {:formal} formal_1_1492_14 == 15;
      assume {:formal} formal_1_1492_15 == 16;
      assume {:formal} formal_1_1492_16 == 17;
      assume {:formal} formal_1_1492_17 == 18;
      assert {:keepAssertion} !(receiver.IsValid() && receiver.View() == [formal_1_1492_0, formal_1_1492_1, formal_1_1492_2, formal_1_1492_3, formal_1_1492_4, formal_1_1492_5, formal_1_1492_6, formal_1_1492_7, formal_1_1492_8, formal_1_1492_9, formal_1_1492_10, formal_1_1492_11, formal_1_1492_12, formal_1_1492_13, formal_1_1492_14, formal_1_1492_15, formal_1_1492_16, formal_1_1492_17]);
    }
2024-10-02 03:01:42.5087 DEBUG Trying method sequence: Rotate
2024-10-02 03:01:42.5120 TRACE Verifying the body of the following method:
static method synthesized(formal_1_1492_0: int, formal_1_1492_1: int, formal_1_1492_2: int, formal_1_1492_3: int, formal_1_1492_4: int, formal_1_1492_5: int, formal_1_1492_6: int, formal_1_1492_7: int, formal_1_1492_8: int, formal_1_1492_9: int, formal_1_1492_10: int, formal_1_1492_11: int, formal_1_1492_12: int, formal_1_1492_13: int, formal_1_1492_14: int, formal_1_1492_15: int, formal_1_1492_16: int, formal_1_1492_17: int, receiver: Queue)
    modifies receiver, receiver.Repr {assume !(receiver.IsValid() && receiver.View() == [0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]);
assume true && receiver.IsValid() && 0 < |receiver.Repr|;
receiver.Rotate();
assert {:keepAssertion} !(receiver.IsValid() && receiver.View() == [0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]);}
2024-10-02 03:01:42.5120 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_1_1492_0: int, formal_1_1492_1: int, formal_1_1492_2: int, formal_1_1492_3: int, formal_1_1492_4: int, formal_1_1492_5: int, formal_1_1492_6: int, formal_1_1492_7: int, formal_1_1492_8: int, formal_1_1492_9: int, formal_1_1492_10: int, formal_1_1492_11: int, formal_1_1492_12: int, formal_1_1492_13: int, formal_1_1492_14: int, formal_1_1492_15: int, formal_1_1492_16: int, formal_1_1492_17: int, receiver: Queue)
      modifies receiver, receiver.Repr
    {
      assume {:formal} formal_1_1492_0 == 0;
      assume {:formal} formal_1_1492_1 == 1;
      assume {:formal} formal_1_1492_2 == 2;
      assume {:formal} formal_1_1492_3 == 4;
      assume {:formal} formal_1_1492_4 == 5;
      assume {:formal} formal_1_1492_5 == 6;
      assume {:formal} formal_1_1492_6 == 7;
      assume {:formal} formal_1_1492_7 == 8;
      assume {:formal} formal_1_1492_8 == 9;
      assume {:formal} formal_1_1492_9 == 10;
      assume {:formal} formal_1_1492_10 == 11;
      assume {:formal} formal_1_1492_11 == 12;
      assume {:formal} formal_1_1492_12 == 13;
      assume {:formal} formal_1_1492_13 == 14;
      assume {:formal} formal_1_1492_14 == 15;
      assume {:formal} formal_1_1492_15 == 16;
      assume {:formal} formal_1_1492_16 == 17;
      assume {:formal} formal_1_1492_17 == 18;
      assume !(receiver.IsValid() && receiver.View() == [formal_1_1492_0, formal_1_1492_1, formal_1_1492_2, formal_1_1492_3, formal_1_1492_4, formal_1_1492_5, formal_1_1492_6, formal_1_1492_7, formal_1_1492_8, formal_1_1492_9, formal_1_1492_10, formal_1_1492_11, formal_1_1492_12, formal_1_1492_13, formal_1_1492_14, formal_1_1492_15, formal_1_1492_16, formal_1_1492_17]);
      assume true && receiver.IsValid() && 0 < |receiver.Repr|;
      receiver.Rotate();
      assert {:keepAssertion} !(receiver.IsValid() && receiver.View() == [formal_1_1492_0, formal_1_1492_1, formal_1_1492_2, formal_1_1492_3, formal_1_1492_4, formal_1_1492_5, formal_1_1492_6, formal_1_1492_7, formal_1_1492_8, formal_1_1492_9, formal_1_1492_10, formal_1_1492_11, formal_1_1492_12, formal_1_1492_13, formal_1_1492_14, formal_1_1492_15, formal_1_1492_16, formal_1_1492_17]);
    }
2024-10-02 03:01:43.1798 TRACE Verifying the body of the following method:
static method synthesized(formal_3_1010_0: int, formal_4_1012_0: int, formal_5_1016_0: int, formal_6_1018_0: int, formal_7_1020_0: int, formal_8_1022_0: int, formal_9_1024_0: int, formal_10_1026_0: int, formal_11_1028_0: int, formal_12_1034_0: int, formal_13_1082_0: int, formal_14_1104_0: int, formal_15_1106_0: int, formal_16_1108_0: int, formal_17_1110_0: int, formal_18_1112_0: int, formal_19_1014_0: int, formal_20_1060_0: int, formal_21_1551_0: int, formal_22_1124_0: int, formal_23_1126_0: int, formal_24_1128_0: int, formal_25_1130_0: int, formal_26_1132_0: int, formal_27_1134_0: int, formal_28_1142_0: int, formal_29_1186_0: int, formal_30_1206_0: int, formal_31_1208_0: int, formal_32_1210_0: int, formal_33_1212_0: int, formal_34_1214_0: int, formal_35_1122_0: int, formal_36_1567_0: int, formal_37_1569_0: int, formal_37_1569_1: int, formal_38_1218_0: int, formal_39_1572_0: int, formal_39_1572_1: int, formal_40_1574_0: int, formal_40_1574_1: int, formal_41_1576_0: int, formal_41_1576_1: int, formal_42_1578_0: int, formal_42_1578_1: int, formal_43_1580_0: int, formal_43_1580_1: int, formal_44_1582_0: int, formal_44_1582_1: int, formal_45_1584_0: int, formal_45_1584_1: int, formal_46_1586_0: int, formal_47_1588_0: int, formal_48_1590_0: int, formal_49_1592_0: int, formal_50_1594_0: int, formal_50_1594_1: int, formal_51_1596_0: int, formal_51_1596_1: int, formal_52_1598_0: int, formal_52_1598_1: int, formal_53_1600_0: int, formal_53_1600_1: int, formal_54_1602_0: int, formal_54_1602_1: int, formal_55_1604_0: int, formal_55_1604_1: int, formal_56_1606_0: int, formal_56_1606_1: int, formal_57_1608_0: int, formal_57_1608_1: int, formal_59_734_0: bool, formal_60_1612_0: int, formal_60_1612_1: int, formal_61_1614_0: int, formal_62_1360_0: int, formal_62_1360_1: int, formal_63_1358_0: int, formal_63_1358_1: int, formal_64_1362_0: int, formal_64_1362_1: int, formal_65_1364_0: int, formal_65_1364_1: int, formal_66_1366_0: int, formal_66_1366_1: int, formal_67_1368_0: int, formal_67_1368_1: int, formal_68_1622_0: int, formal_70_1625_0: int, formal_70_1625_1: int, formal_71_1627_0: int, formal_71_1627_1: int, formal_72_1438_0: int, formal_72_1438_1: int, formal_73_1440_0: int, formal_73_1440_1: int, formal_74_1442_0: int, formal_74_1442_1: int, formal_75_1444_0: int, formal_75_1444_1: int, formal_76_217_0: int, formal_76_217_1: int, formal_77_1356_0: int, formal_77_1356_1: int, formal_1_1492_0: int, formal_1_1492_1: int, formal_1_1492_2: int, formal_1_1492_3: int, formal_1_1492_4: int, formal_1_1492_5: int, formal_1_1492_6: int, formal_1_1492_7: int, formal_1_1492_8: int, formal_1_1492_9: int, formal_1_1492_10: int, formal_1_1492_11: int, formal_1_1492_12: int, formal_1_1492_13: int, formal_1_1492_14: int, formal_1_1492_15: int, formal_1_1492_16: int, formal_1_1492_17: int, receiver: Queue)
    modifies receiver, receiver.Repr {assume !(receiver == null);
assume !(receiver.head == null);
assume !(receiver.tail == null);
assume |receiver.Repr| > 0;
assume |receiver.Repr| > 1;
assume |receiver.Repr| > 11;
assume |receiver.Repr| > 12;
assume |receiver.Repr| > 13;
assume |receiver.Repr| > 14;
assume |receiver.Repr| > 15;
assume |receiver.Repr| > 16;
assume |receiver.Repr| > 17;
assume |receiver.Repr| > 2;
assume |receiver.Repr| > 4;
assume |receiver.Repr| > 5;
assume |receiver.Repr| > 6;
assume |receiver.Repr| > 7;
assume |receiver.Repr| > 8;
assume |receiver.Repr| > 9;
assume |receiver.Repr| > 10;
assume |receiver.Repr| > 3;
assume !(receiver.Repr[1] == null);
assume !(receiver.Repr[11] == null);
assume !(receiver.Repr[12] == null);

********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
****************** SKIPPING 28504 LINES OF LOGS TO SAVE DISK SPACE *************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************

      assert {:keepAssertion} receiver.head == receiver.tail;
      assert {:keepAssertion} null == receiver.head.next;
    }
2024-10-02 03:24:32.1455 DEBUG Using integer programming to estimating the distance to |this.Repr| > 0, |this.Repr| > 1, receiver.tail == receiver.head.next, this.tail == this.Repr[1], ¬(receiver.tail == null), this.head == this.Repr[0], ¬(receiver.head == null), receiver.IsValid.requires(), ¬(receiver == null), null == receiver.tail.next, 2 == |this.Repr|, 0 == this.tail.data, 50 == this.head.data, true == this.IsValid()
2024-10-02 03:24:32.1487 TRACE Adding solver constraint for property |this.Repr| > default0 from False to True: ((Enqueue * 1) + (Enqueue * 0)) >= 2
2024-10-02 03:24:32.1487 TRACE Adding solver constraint for property |this.Repr| > default0 from False to True: ((Enqueue * 1) + (Enqueue * 0)) >= 2
2024-10-02 03:24:32.1487 TRACE Adding solver constraint for property this.tail == this.Repr[default0] from Undefined to True: (((Enqueue * 1) + (Enqueue * 0)) + ((Dequeue * 0) + (Dequeue * 0))) >= 1
2024-10-02 03:24:32.1487 TRACE Adding solver constraint for property this.tail == this.Repr[default0] from Undefined to True: (((Enqueue * 1) + (Enqueue * 0)) + ((Dequeue * 0) + (Dequeue * 1))) >= 1
2024-10-02 03:24:32.1487 TRACE Adding solver constraint for property this.head == this.Repr[default0] from Undefined to True: ((((Rotate * 0) + (Rotate * 0)) + ((Enqueue * 1) + (Enqueue * 1))) + ((Dequeue * 0) + (Dequeue * 0))) >= 1
2024-10-02 03:24:32.1487 TRACE Adding solver constraint for property this.head == this.Repr[default0] from Undefined to True: ((((Rotate * 0) + (Rotate * 10000)) + ((Enqueue * 1) + (Enqueue * 0))) + ((Dequeue * 0) + (Dequeue * 10000))) >= 1
2024-10-02 03:24:32.1487 TRACE Adding solver constraint for property default0 == |this.Repr| from False to True: (((Enqueue * 1) + (Enqueue * 0)) + ((Dequeue * 1) + (Dequeue * 0))) >= 1
2024-10-02 03:24:32.1487 TRACE Adding solver constraint for property default0 == |this.Repr| from False to True: (((Enqueue * 1) + (Enqueue * 0)) + ((Dequeue * 1) + (Dequeue * 0))) >= 1
2024-10-02 03:24:32.1487 TRACE Minimizing value: ((((Rotate + IsEmpty) + Enqueue) + Front) + Dequeue)
2024-10-02 03:24:32.1487 DEBUG The integer programming gives the lower bound of 2 methods.
2024-10-02 03:24:32.1487 DEBUG In particular, need at least -0 calls to Rotate
2024-10-02 03:24:32.1487 DEBUG In particular, need at least -0 calls to IsEmpty
2024-10-02 03:24:32.1487 DEBUG In particular, need at least 2 calls to Enqueue
2024-10-02 03:24:32.1487 DEBUG In particular, need at least -0 calls to Front
2024-10-02 03:24:32.1487 DEBUG In particular, need at least -0 calls to Dequeue
2024-10-02 03:24:32.1487 INFO The following method sequence is possible (heuristic=2): Dequeue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue
2024-10-02 03:24:32.1487 INFO New state is |this.Repr| > 0, |this.Repr| > 1, receiver.tail == receiver.head.next, this.tail == this.Repr[1], ¬(receiver.tail == null), this.head == this.Repr[0], ¬(receiver.head == null), receiver.IsValid.requires(), ¬(receiver == null), null == receiver.tail.next, 2 == |this.Repr|, 0 == this.tail.data, 50 == this.head.data, true == this.IsValid()
2024-10-02 03:24:32.1487 INFO Expanding method sequence Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue, Enqueue -- estimated distance to start = 0, distance to end = 18
2024-10-02 03:24:32.1511 TRACE Verifying the body of the following method:
static method synthesized(formal_2_734_0: bool) returns (receiver: Queue) {assume true;
receiver := new Queue();
assert {:keepAssertion} !(!(receiver == null) && receiver.IsValid.requires() && true == receiver.IsValid() && null == receiver.head && null == receiver.tail && [] == receiver.Repr);}
2024-10-02 03:24:32.1511 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_2_734_0: bool) returns (receiver: Queue)
    {
      assume true;
      receiver := new Queue();
      assume {:formal} formal_2_734_0 == true;
      assert {:keepAssertion} !(!(receiver == null) && receiver.IsValid.requires() && formal_2_734_0 == receiver.IsValid() && null == receiver.head && null == receiver.tail && [] == receiver.Repr);
    }
2024-10-02 03:24:32.4457 TRACE Verifying the body of the following method:
static method synthesized(formal_2_734_0: bool) returns (receiver: Queue) {assume true;
receiver := new Queue();
assert {:keepAssertion} !(receiver == null) && receiver.IsValid.requires() && true == receiver.IsValid() && null == receiver.head && null == receiver.tail && [] == receiver.Repr;}
2024-10-02 03:24:32.4457 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_2_734_0: bool) returns (receiver: Queue)
    {
      assume true;
      receiver := new Queue();
      assume {:formal} formal_2_734_0 == true;
      assert {:keepAssertion} !(receiver == null) && receiver.IsValid.requires() && formal_2_734_0 == receiver.IsValid() && null == receiver.head && null == receiver.tail && [] == receiver.Repr;
    }
2024-10-02 03:24:32.6751 INFO Have found the following solution to a subproblem!
{
result := new Queue();
result.Enqueue(0);
result.Enqueue(1);
result.Enqueue(2);
result.Enqueue(4);
result.Enqueue(5);
result.Enqueue(6);
result.Enqueue(7);
result.Enqueue(8);
result.Enqueue(9);
result.Enqueue(10);
result.Enqueue(11);
result.Enqueue(12);
result.Enqueue(13);
result.Enqueue(14);
result.Enqueue(15);
result.Enqueue(16);
result.Enqueue(17);
result.Enqueue(18);
}
2024-10-02 03:24:32.6751 INFO Time spend on subproblem: 00:22:51.3000023
2024-10-02 03:24:32.6792 INFO Number of Regular queries to Dafny used to solve subproblem: 147 (00:03:48.6137410)
2024-10-02 03:24:32.6792 INFO Number of Simplify queries to Dafny used to solve subproblem: 36 (00:17:58.9172172)
2024-10-02 03:24:32.6792 INFO Number of Heuristic queries to Dafny used to solve subproblem: 195 (00:00:53.9561777)
2024-10-02 03:24:32.6792 INFO Have found the following solution!
static method solution() returns (result:Queue)
ensures Goal(result)
{
result := new Queue();
result.Enqueue(0);
result.Enqueue(1);
result.Enqueue(2);
result.Enqueue(4);
result.Enqueue(5);
result.Enqueue(6);
result.Enqueue(7);
result.Enqueue(8);
result.Enqueue(9);
result.Enqueue(10);
result.Enqueue(11);
result.Enqueue(12);
result.Enqueue(13);
result.Enqueue(14);
result.Enqueue(15);
result.Enqueue(16);
result.Enqueue(17);
result.Enqueue(18);
}
2024-10-02 03:24:32.6792 INFO Total time spend on synthesis: 00:22:51.8957120
2024-10-02 03:24:32.6792 INFO Total number of Regular queries to Dafny: 147 (00:03:48.6137410)
2024-10-02 03:24:32.6792 INFO Total number of Simplify queries to Dafny: 36 (00:17:58.9172172)
2024-10-02 03:24:32.6792 INFO Total number of Heuristic queries to Dafny: 195 (00:00:53.9561777)
