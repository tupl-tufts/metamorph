2025-02-25 20:29:03.6609 DEBUG Using integer programming to estimating the distance to receiver.exitCode == INTEGER_OVERFLOW
2025-02-25 20:29:04.0331 TRACE Minimizing value: ((((((((((Push + Pop) + Add) + Sub) + Div) + Mul) + Jump) + Jz) + NOP) + Store) + Load)
2025-02-25 20:29:04.0395 DEBUG The integer programming gives the lower bound of 0 methods.
2025-02-25 20:29:04.0399 DEBUG In particular, need at least -0 calls to Push
2025-02-25 20:29:04.0399 DEBUG In particular, need at least -0 calls to Pop
2025-02-25 20:29:04.0399 DEBUG In particular, need at least -0 calls to Add
2025-02-25 20:29:04.0399 DEBUG In particular, need at least -0 calls to Sub
2025-02-25 20:29:04.0399 DEBUG In particular, need at least -0 calls to Div
2025-02-25 20:29:04.0399 DEBUG In particular, need at least -0 calls to Mul
2025-02-25 20:29:04.0399 DEBUG In particular, need at least -0 calls to Jump
2025-02-25 20:29:04.0399 DEBUG In particular, need at least -0 calls to Jz
2025-02-25 20:29:04.0399 DEBUG In particular, need at least -0 calls to NOP
2025-02-25 20:29:04.0399 DEBUG In particular, need at least -0 calls to Store
2025-02-25 20:29:04.0399 DEBUG In particular, need at least -0 calls to Load
2025-02-25 20:29:04.0409 INFO Initial heuristic value is 0
2025-02-25 20:29:04.0432 INFO Expanding method sequence  -- estimated distance to start = 0, distance to end = 0
2025-02-25 20:29:04.0788 TRACE Verifying the body of the following method:
static method synthesized(argument_1_0_0: nat) returns (receiver: VM) {receiver := new VM(argument_1_0_0);
assert {:keepAssertion} !(receiver.exitCode == INTEGER_OVERFLOW);}
2025-02-25 20:29:04.0790 TRACE Verifying the body of the following method (literal):
 static method synthesized(argument_1_0_0: nat) returns (receiver: VM)
    {
      assume true;
      receiver := new VM(argument_1_0_0);
      assert {:keepAssertion} !(receiver.exitCode == INTEGER_OVERFLOW);
    }
2025-02-25 20:29:04.7872 DEBUG Trying method sequence: Push
2025-02-25 20:29:04.7924 TRACE Verifying the body of the following method:
static method synthesized(argument_2_0_0: nat, receiver: VM)
    modifies receiver {assume !(receiver.exitCode == INTEGER_OVERFLOW);
assume true && receiver.IsValid() && receiver.IsRunning() && argument_2_0_0 <= MAX_WORD && receiver.pc > 0;
receiver.Push(argument_2_0_0);
assert {:keepAssertion} !(receiver.exitCode == INTEGER_OVERFLOW);}
2025-02-25 20:29:04.7924 TRACE Verifying the body of the following method (literal):
 static method synthesized(argument_2_0_0: nat, receiver: VM)
      modifies receiver
    {
      assume !(receiver.exitCode == INTEGER_OVERFLOW);
      assume true && receiver.IsValid() && receiver.IsRunning() && argument_2_0_0 <= MAX_WORD && receiver.pc > 0;
      receiver.Push(argument_2_0_0);
      assert {:keepAssertion} !(receiver.exitCode == INTEGER_OVERFLOW);
    }
2025-02-25 20:29:05.1099 DEBUG Trying method sequence: Pop
2025-02-25 20:29:05.1146 TRACE Verifying the body of the following method:
static method synthesized(receiver: VM)
    modifies receiver {assume !(receiver.exitCode == INTEGER_OVERFLOW);
assume true && receiver.IsValid() && receiver.IsRunning() && receiver.pc > 0;
var _ := receiver.Pop();
assert {:keepAssertion} !(receiver.exitCode == INTEGER_OVERFLOW);}
2025-02-25 20:29:05.1147 TRACE Verifying the body of the following method (literal):
 static method synthesized(receiver: VM)
      modifies receiver
    {
      assume !(receiver.exitCode == INTEGER_OVERFLOW);
      assume true && receiver.IsValid() && receiver.IsRunning() && receiver.pc > 0;
      var _ := receiver.Pop();
      assert {:keepAssertion} !(receiver.exitCode == INTEGER_OVERFLOW);
    }
2025-02-25 20:29:05.4551 DEBUG Trying method sequence: Add
2025-02-25 20:29:05.4566 TRACE Verifying the body of the following method:
static method synthesized(receiver: VM)
    modifies receiver {assume !(receiver.exitCode == INTEGER_OVERFLOW);
assume true && receiver.IsValid() && receiver.IsRunning() && receiver.pc > 0;
receiver.Add();
assert {:keepAssertion} !(receiver.exitCode == INTEGER_OVERFLOW);}
2025-02-25 20:29:05.4566 TRACE Verifying the body of the following method (literal):
 static method synthesized(receiver: VM)
      modifies receiver
    {
      assume !(receiver.exitCode == INTEGER_OVERFLOW);
      assume true && receiver.IsValid() && receiver.IsRunning() && receiver.pc > 0;
      receiver.Add();
      assert {:keepAssertion} !(receiver.exitCode == INTEGER_OVERFLOW);
    }
2025-02-25 20:29:05.8189 TRACE Verifying the body of the following method:
static method synthesized(formal_1_1065_0: int, formal_2_1067_0: int, formal_4_1140_0: bool, formal_6_600_0: bool, formal_7_1165_0: int, formal_8_533_0: int, formal_9_1168_0: int, formal_10_1170_0: int, formal_10_1170_1: int, formal_11_1172_0: int, formal_11_1172_1: int, receiver: VM)
    modifies receiver {assume !(receiver == null);
assume |receiver.stack| > 0;
assume |receiver.stack| > 1;
assume receiver.IsRunning.requires();
assume true == receiver.IsRunning();
assume receiver.IsValid.requires();
assume true == receiver.IsValid();
assume 8366 == receiver.pc;
assume 5 == |receiver.data|;
assume 2 == |receiver.stack|;
assume 610 == receiver.stack[0];
assume 64926 == receiver.stack[1];
assume receiver.exitCode == Imports.ExitCode.OK;
receiver.Add();
assert {:keepAssertion} receiver.exitCode == INTEGER_OVERFLOW;}
2025-02-25 20:29:05.8189 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_1_1065_0: int, formal_2_1067_0: int, formal_4_1140_0: bool, formal_6_600_0: bool, formal_7_1165_0: int, formal_8_533_0: int, formal_9_1168_0: int, formal_10_1170_0: int, formal_10_1170_1: int, formal_11_1172_0: int, formal_11_1172_1: int, receiver: VM)
      modifies receiver
    {
      assume {:formal} formal_1_1065_0 == 0;
      assume {:formal} formal_2_1067_0 == 1;
      assume {:formal} formal_4_1140_0 == true;
      assume {:formal} formal_6_600_0 == true;
      assume {:formal} formal_7_1165_0 == 8366;

********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
****************** SKIPPING 4608 LINES OF LOGS TO SAVE DISK SPACE **************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************

      assume receiver.IsRunning.requires();
      assume formal_4_1140_0 == receiver.IsRunning();
      assume receiver.IsValid.requires();
      assume formal_6_600_0 == receiver.IsValid();
      assume formal_7_533_0 == |receiver.data|;
      assume receiver.exitCode == Imports.ExitCode.OK;
      receiver.Load(argument_92_0_0);
      assume {:formal} formal_1_1065_0 == 0;
      assume {:formal} formal_2_1213_0 == 64926;
      assume {:formal} formal_2_1213_1 == 0;
      assume {:formal} formal_3_201_0 == 1;
      assume {:formal} formal_5_1140_0 == true;
      assume {:formal} formal_7_600_0 == true;
      assume {:formal} formal_8_533_0 == 5;
      assume {:formal} formal_9_1221_0 == 8367;
      assert {:keepAssertion} !(receiver == null);
      assert {:keepAssertion} |receiver.stack| > formal_1_1065_0;
      assert {:keepAssertion} formal_2_1213_0 == receiver.stack[formal_2_1213_1];
      assert {:keepAssertion} formal_3_201_0 == |receiver.stack|;
      assert {:keepAssertion} receiver.IsRunning.requires();
      assert {:keepAssertion} formal_5_1140_0 == receiver.IsRunning();
      assert {:keepAssertion} receiver.IsValid.requires();
      assert {:keepAssertion} formal_7_600_0 == receiver.IsValid();
      assert {:keepAssertion} formal_8_533_0 == |receiver.data|;
      assert {:keepAssertion} formal_9_1221_0 == receiver.pc;
      assert {:keepAssertion} receiver.exitCode == Imports.ExitCode.OK;
    }
2025-02-25 20:29:47.7128 DEBUG Using integer programming to estimating the distance to |this.data| > 3, receiver.exitCode == Imports.ExitCode.OK, receiver.IsValid.requires(), receiver.IsRunning.requires(), ¬(receiver == null), 5 == |this.data|, 8368 == this.pc, 64926 == this.data[3], true == this.IsValid(), true == this.IsRunning(), [] == receiver.stack
2025-02-25 20:29:47.7138 TRACE Minimizing value: ((((((((((Push + Pop) + Add) + Sub) + Div) + Mul) + Jump) + Jz) + NOP) + Store) + Load)
2025-02-25 20:29:47.7138 DEBUG The integer programming gives the lower bound of 0 methods.
2025-02-25 20:29:47.7138 DEBUG In particular, need at least -0 calls to Push
2025-02-25 20:29:47.7138 DEBUG In particular, need at least -0 calls to Pop
2025-02-25 20:29:47.7138 DEBUG In particular, need at least -0 calls to Add
2025-02-25 20:29:47.7138 DEBUG In particular, need at least -0 calls to Sub
2025-02-25 20:29:47.7138 DEBUG In particular, need at least -0 calls to Div
2025-02-25 20:29:47.7138 DEBUG In particular, need at least -0 calls to Mul
2025-02-25 20:29:47.7138 DEBUG In particular, need at least -0 calls to Jump
2025-02-25 20:29:47.7138 DEBUG In particular, need at least -0 calls to Jz
2025-02-25 20:29:47.7138 DEBUG In particular, need at least -0 calls to NOP
2025-02-25 20:29:47.7138 DEBUG In particular, need at least -0 calls to Store
2025-02-25 20:29:47.7138 DEBUG In particular, need at least -0 calls to Load
2025-02-25 20:29:47.7138 INFO The following method sequence is possible (heuristic=0): Load, Push, Add
2025-02-25 20:29:47.7138 INFO New state is |this.data| > 3, receiver.exitCode == Imports.ExitCode.OK, receiver.IsValid.requires(), receiver.IsRunning.requires(), ¬(receiver == null), 5 == |this.data|, 8368 == this.pc, 64926 == this.data[3], true == this.IsValid(), true == this.IsRunning(), [] == receiver.stack
2025-02-25 20:29:47.7138 INFO Expanding method sequence Push, Push, Add -- estimated distance to start = 0, distance to end = 3
2025-02-25 20:29:47.7161 TRACE Verifying the body of the following method:
static method synthesized(formal_2_1140_0: bool, formal_4_600_0: bool, formal_5_533_0: int, formal_7_1512_0: int, argument_93_0_0: nat) returns (receiver: VM) {receiver := new VM(argument_93_0_0);
assert {:keepAssertion} !(!(receiver == null) && receiver.IsRunning.requires() && true == receiver.IsRunning() && receiver.IsValid.requires() && true == receiver.IsValid() && 5 == |receiver.data| && [] == receiver.stack && 8368 == receiver.pc && receiver.exitCode == Imports.ExitCode.OK);}
2025-02-25 20:29:47.7161 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_2_1140_0: bool, formal_4_600_0: bool, formal_5_533_0: int, formal_7_1512_0: int, argument_93_0_0: nat)
        returns (receiver: VM)
    {
      assume true;
      receiver := new VM(argument_93_0_0);
      assume {:formal} formal_2_1140_0 == true;
      assume {:formal} formal_4_600_0 == true;
      assume {:formal} formal_5_533_0 == 5;
      assume {:formal} formal_7_1512_0 == 8368;
      assert {:keepAssertion} !(!(receiver == null) && receiver.IsRunning.requires() && formal_2_1140_0 == receiver.IsRunning() && receiver.IsValid.requires() && formal_4_600_0 == receiver.IsValid() && formal_5_533_0 == |receiver.data| && [] == receiver.stack && formal_7_1512_0 == receiver.pc && receiver.exitCode == Imports.ExitCode.OK);
    }
2025-02-25 20:29:48.0159 TRACE Verifying the body of the following method:
static method synthesized(formal_2_1140_0: bool, formal_4_600_0: bool, formal_5_533_0: int, formal_7_1512_0: int, argument_93_0_0: nat, formal_0_1730_0: int) returns (receiver: VM) {receiver := new VM(8368);
assert {:keepAssertion} !(receiver == null) && receiver.IsRunning.requires() && true == receiver.IsRunning() && receiver.IsValid.requires() && true == receiver.IsValid() && 5 == |receiver.data| && [] == receiver.stack && 8368 == receiver.pc && receiver.exitCode == Imports.ExitCode.OK;}
2025-02-25 20:29:48.0159 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_2_1140_0: bool, formal_4_600_0: bool, formal_5_533_0: int, formal_7_1512_0: int, argument_93_0_0: nat, formal_0_1730_0: int)
        returns (receiver: VM)
    {
      assume {:formal} formal_0_1730_0 == 8368;
      assume {:attribute 561} argument_93_0_0 == formal_0_1730_0;
      assume true;
      receiver := new VM(argument_93_0_0);
      assume {:formal} formal_2_1140_0 == true;
      assume {:formal} formal_4_600_0 == true;
      assume {:formal} formal_5_533_0 == 5;
      assume {:formal} formal_7_1512_0 == 8368;
      assert {:keepAssertion} !(receiver == null) && receiver.IsRunning.requires() && formal_2_1140_0 == receiver.IsRunning() && receiver.IsValid.requires() && formal_4_600_0 == receiver.IsValid() && formal_5_533_0 == |receiver.data| && [] == receiver.stack && formal_7_1512_0 == receiver.pc && receiver.exitCode == Imports.ExitCode.OK;
    }
2025-02-25 20:29:48.2980 INFO Have found the following solution to a subproblem!
{
result := new VM(8368);
result.Push(64926);
result.Push(610);
result.Add();
}
2025-02-25 20:29:48.2985 INFO Time spend on subproblem: 00:00:44.6453920
2025-02-25 20:29:48.2985 INFO Number of Regular queries to Dafny used to solve subproblem: 60 (00:00:19.1303380)
2025-02-25 20:29:48.2985 INFO Number of Simplify queries to Dafny used to solve subproblem: 24 (00:00:08.4194660)
2025-02-25 20:29:48.2985 INFO Number of Heuristic queries to Dafny used to solve subproblem: 58 (00:00:16.5366080)
2025-02-25 20:29:48.2985 INFO Have found the following solution!
static method solution() returns (result:VM)
ensures fresh(result) && Goal(result)
{
result := new VM(8368);
result.Push(64926);
result.Push(610);
result.Add();
}
2025-02-25 20:29:48.2985 INFO Total time spend on synthesis: 00:00:44.8870680
2025-02-25 20:29:48.2985 INFO Total number of Regular queries to Dafny: 60 (00:00:19.1303380)
2025-02-25 20:29:48.2985 INFO Total number of Simplify queries to Dafny: 24 (00:00:08.4194660)
2025-02-25 20:29:48.2985 INFO Total number of Heuristic queries to Dafny: 58 (00:00:16.5366080)
