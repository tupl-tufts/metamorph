2024-09-23 14:05:30.0526 DEBUG Using integer programming to estimating the distance to this.View() == [0, 1, 2, 4, 5, 6, 7, 8], receiver.IsValid()
2024-09-23 14:05:30.0668 TRACE Minimizing value: (((PushBack + PushFront) + PopFront) + PopBack)
2024-09-23 14:05:30.0668 DEBUG The integer programming gives the lower bound of 0 methods.
2024-09-23 14:05:30.0668 DEBUG In particular, need at least -0 calls to PushBack
2024-09-23 14:05:30.0668 DEBUG In particular, need at least -0 calls to PushFront
2024-09-23 14:05:30.0668 DEBUG In particular, need at least -0 calls to PopFront
2024-09-23 14:05:30.0668 DEBUG In particular, need at least -0 calls to PopBack
2024-09-23 14:05:30.0668 INFO Initial heuristic value is 0
2024-09-23 14:05:30.0723 INFO Expanding method sequence  -- estimated distance to start = 0, distance to end = 0
2024-09-23 14:05:30.1132 TRACE Verifying the body of the following method:
static method synthesized(formal_1_729_0: int, formal_1_729_1: int, formal_1_729_2: int, formal_1_729_3: int, formal_1_729_4: int, formal_1_729_5: int, formal_1_729_6: int, formal_1_729_7: int) returns (receiver: List) {assume true;
receiver := new List();
assert {:keepAssertion} !(receiver.IsValid() && receiver.View() == [0, 1, 2, 4, 5, 6, 7, 8]);}
2024-09-23 14:05:30.1132 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_1_729_0: int, formal_1_729_1: int, formal_1_729_2: int, formal_1_729_3: int, formal_1_729_4: int, formal_1_729_5: int, formal_1_729_6: int, formal_1_729_7: int)
        returns (receiver: List)
    {
      assume true;
      receiver := new List();
      assume {:formal} formal_1_729_0 == 0;
      assume {:formal} formal_1_729_1 == 1;
      assume {:formal} formal_1_729_2 == 2;
      assume {:formal} formal_1_729_3 == 4;
      assume {:formal} formal_1_729_4 == 5;
      assume {:formal} formal_1_729_5 == 6;
      assume {:formal} formal_1_729_6 == 7;
      assume {:formal} formal_1_729_7 == 8;
      assert {:keepAssertion} !(receiver.IsValid() && receiver.View() == [formal_1_729_0, formal_1_729_1, formal_1_729_2, formal_1_729_3, formal_1_729_4, formal_1_729_5, formal_1_729_6, formal_1_729_7]);
    }
2024-09-23 14:05:31.2597 DEBUG Trying method sequence: PushBack
2024-09-23 14:05:31.2684 TRACE Verifying the body of the following method:
static method synthesized(formal_1_729_0: int, formal_1_729_1: int, formal_1_729_2: int, formal_1_729_3: int, formal_1_729_4: int, formal_1_729_5: int, formal_1_729_6: int, formal_1_729_7: int, argument_2_0_0: int, receiver: List)
    modifies receiver, receiver.Repr {assume !(receiver.IsValid() && receiver.View() == [0, 1, 2, 4, 5, 6, 7, 8]);
assume true && receiver.IsValid();
receiver.PushBack(argument_2_0_0);
assert {:keepAssertion} !(receiver.IsValid() && receiver.View() == [0, 1, 2, 4, 5, 6, 7, 8]);}
2024-09-23 14:05:31.2684 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_1_729_0: int, formal_1_729_1: int, formal_1_729_2: int, formal_1_729_3: int, formal_1_729_4: int, formal_1_729_5: int, formal_1_729_6: int, formal_1_729_7: int, argument_2_0_0: int, receiver: List)
      modifies receiver, receiver.Repr
    {
      assume {:formal} formal_1_729_0 == 0;
      assume {:formal} formal_1_729_1 == 1;
      assume {:formal} formal_1_729_2 == 2;
      assume {:formal} formal_1_729_3 == 4;
      assume {:formal} formal_1_729_4 == 5;
      assume {:formal} formal_1_729_5 == 6;
      assume {:formal} formal_1_729_6 == 7;
      assume {:formal} formal_1_729_7 == 8;
      assume !(receiver.IsValid() && receiver.View() == [formal_1_729_0, formal_1_729_1, formal_1_729_2, formal_1_729_3, formal_1_729_4, formal_1_729_5, formal_1_729_6, formal_1_729_7]);
      assume true && receiver.IsValid();
      receiver.PushBack(argument_2_0_0);
      assert {:keepAssertion} !(receiver.IsValid() && receiver.View() == [formal_1_729_0, formal_1_729_1, formal_1_729_2, formal_1_729_3, formal_1_729_4, formal_1_729_5, formal_1_729_6, formal_1_729_7]);
    }
2024-09-23 14:05:31.8252 TRACE Verifying the body of the following method:
static method synthesized(formal_3_684_0: int, formal_4_686_0: int, formal_5_688_0: int, formal_6_754_0: int, formal_7_756_0: int, formal_8_758_0: int, formal_9_0_0: int, formal_10_761_0: int, formal_11_763_0: int, formal_12_765_0: int, formal_13_767_0: int, formal_14_769_0: int, formal_15_771_0: int, formal_16_197_0: int, formal_17_774_0: int, formal_17_774_1: int, formal_18_776_0: int, formal_18_776_1: int, formal_19_778_0: int, formal_19_778_1: int, formal_20_780_0: int, formal_20_780_1: int, formal_21_782_0: int, formal_21_782_1: int, formal_22_784_0: int, formal_23_786_0: int, formal_24_788_0: int, formal_26_342_0: bool, formal_27_792_0: int, formal_27_792_1: int, formal_28_794_0: int, formal_29_796_0: int, formal_29_796_1: int, formal_30_798_0: int, formal_31_800_0: int, formal_31_800_1: int, formal_32_802_0: int, formal_32_802_1: int, formal_33_804_0: int, formal_33_804_1: int, formal_34_806_0: int, formal_34_806_1: int, formal_35_808_0: int, formal_35_808_1: int, formal_36_810_0: int, formal_36_810_1: int, formal_37_812_0: int, formal_38_814_0: int, formal_1_729_0: int, formal_1_729_1: int, formal_1_729_2: int, formal_1_729_3: int, formal_1_729_4: int, formal_1_729_5: int, formal_1_729_6: int, formal_1_729_7: int, argument_2_0_0: int, receiver: List, formal_0_745_0: int)
    modifies receiver, receiver.Repr {assume !(receiver == null);
assume !(receiver.head == null);
assume !(receiver.tail == null);
assume |receiver.Repr| > 0;
assume |receiver.Repr| > 1;
assume |receiver.Repr| > 2;
assume |receiver.Repr| > 4;
assume |receiver.Repr| > 5;
assume |receiver.Repr| > 6;
assume |receiver.Repr| > 3;
assume !(receiver.Repr[1] == null);
assume !(receiver.Repr[2] == null);
assume !(receiver.Repr[4] == null);
assume !(receiver.Repr[5] == null);
assume !(receiver.Repr[2].next == null);
assume 0 == receiver.head.value;
assume receiver.head == receiver.Repr[0];
assume 1 == receiver.Repr[1].value;
assume 2 == receiver.Repr[2].value;
assume 4 == receiver.Repr[2].next.value;
assume 5 == receiver.Repr[4].value;
assume 6 == receiver.Repr[5].value;
assume receiver.tail == receiver.Repr[6];
assume 7 == receiver.tail.value;
assume 7 == |receiver.Repr|;
assume receiver.IsValid.requires();
assume true == receiver.IsValid();
assume receiver.Repr[2] == receiver.Repr[1].next;
assume receiver.head == receiver.Repr[1].prev;
assume receiver.Repr[1] == receiver.Repr[2].prev;
assume receiver.Repr[1] == receiver.head.next;
assume receiver.Repr[2] == receiver.Repr[2].next.prev;
assume receiver.Repr[4] == receiver.Repr[2].next.next;
assume receiver.Repr[2].next == receiver.Repr[4].prev;
assume receiver.Repr[2].next == receiver.Repr[3];
assume receiver.Repr[5] == receiver.Repr[4].next;
assume receiver.Repr[4] == receiver.Repr[5].prev;
assume receiver.tail == receiver.Repr[5].next;
assume receiver.Repr[5] == receiver.tail.prev;
assume null == receiver.tail.next;
assume null == receiver.head.prev;
receiver.PushBack(8);
assert {:keepAssertion} receiver.IsValid() && receiver.View() == [0, 1, 2, 4, 5, 6, 7, 8];}
2024-09-23 14:05:31.8252 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_3_684_0: int, formal_4_686_0: int, formal_5_688_0: int, formal_6_754_0: int, formal_7_756_0: int, formal_8_758_0: int, formal_9_0_0: int, formal_10_761_0: int, formal_11_763_0: int, formal_12_765_0: int, formal_13_767_0: int, formal_14_769_0: int, formal_15_771_0: int, formal_16_197_0: int, formal_17_774_0: int, formal_17_774_1: int, formal_18_776_0: int, formal_18_776_1: int, formal_19_778_0: int, formal_19_778_1: int, formal_20_780_0: int, formal_20_780_1: int, formal_21_782_0: int, formal_21_782_1: int, formal_22_784_0: int, formal_23_786_0: int, formal_24_788_0: int, formal_26_342_0: bool, formal_27_792_0: int, formal_27_792_1: int, formal_28_794_0: int, formal_29_796_0: int, formal_29_796_1: int, formal_30_798_0: int, formal_31_800_0: int, formal_31_800_1: int, formal_32_802_0: int, formal_32_802_1: int, formal_33_804_0: int, formal_33_804_1: int, formal_34_806_0: int, formal_34_806_1: int, formal_35_808_0: int, formal_35_808_1: int, formal_36_810_0: int, formal_36_810_1: int, formal_37_812_0: int, formal_38_814_0: int, formal_1_729_0: int, formal_1_729_1: int, formal_1_729_2: int, formal_1_729_3: int, formal_1_729_4: int, formal_1_729_5: int, formal_1_729_6: int, formal_1_729_7: int, argument_2_0_0: int, receiver: List, formal_0_745_0: int)

********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
****************** SKIPPING 10005 LINES OF LOGS TO SAVE DISK SPACE *************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************

      assume |receiver.Repr| > formal_3_684_0;
      assume formal_5_771_0 == receiver.head.value;
      assume receiver.head == receiver.Repr[formal_6_197_0];
      assume receiver.IsValid.requires();
      assume formal_9_342_0 == receiver.IsValid();
      assume null == receiver.head.prev;
      var _ := receiver.PopBack();
      assume {:formal} formal_2_684_0 == 0;
      assume {:formal} formal_3_2338_0 == 1;
      assume {:formal} formal_4_771_0 == 0;
      assume {:formal} formal_5_197_0 == 0;
      assume {:formal} formal_7_342_0 == true;
      assert {:keepAssertion} !(receiver == null);
      assert {:keepAssertion} !(receiver.head == null);
      assert {:keepAssertion} |receiver.Repr| > formal_2_684_0;
      assert {:keepAssertion} formal_3_2338_0 == |receiver.Repr|;
      assert {:keepAssertion} formal_4_771_0 == receiver.head.value;
      assert {:keepAssertion} receiver.head == receiver.Repr[formal_5_197_0];
      assert {:keepAssertion} receiver.IsValid.requires();
      assert {:keepAssertion} formal_7_342_0 == receiver.IsValid();
      assert {:keepAssertion} receiver.head == receiver.tail;
      assert {:keepAssertion} null == receiver.head.next;
      assert {:keepAssertion} null == receiver.head.prev;
    }
2024-09-23 14:16:51.7447 DEBUG Using integer programming to estimating the distance to |this.Repr| > 0, |this.Repr| > 1, receiver.tail == receiver.head.next, this.tail == this.Repr[1], ¬(receiver.tail == null), receiver.head == receiver.tail.prev, this.head == this.Repr[0], ¬(receiver.head == null), receiver.IsValid.requires(), ¬(receiver == null), null == receiver.tail.next, null == receiver.head.prev, 2 == |this.Repr|, 56 == this.tail.value, 0 == this.head.value, true == this.IsValid()
2024-09-23 14:16:51.7469 TRACE Adding solver constraint for property |this.Repr| > default0 from False to True: (((PushBack * 1) + (PushBack * 0)) + ((PushFront * 1) + (PushFront * 0))) >= 2
2024-09-23 14:16:51.7469 TRACE Adding solver constraint for property |this.Repr| > default0 from False to True: (((PushBack * 1) + (PushBack * 0)) + ((PushFront * 1) + (PushFront * 0))) >= 2
2024-09-23 14:16:51.7469 TRACE Adding solver constraint for property this.tail == this.Repr[default0] from Undefined to True: (((((PushBack * 1) + (PushBack * 0)) + ((PushFront * 1) + (PushFront * 0))) + ((PopFront * 0) + (PopFront * 0))) + ((PopBack * 0) + (PopBack * 0))) >= 1
2024-09-23 14:16:51.7469 TRACE Adding solver constraint for property this.tail == this.Repr[default0] from Undefined to True: (((((PushBack * 1) + (PushBack * 0)) + ((PushFront * 1) + (PushFront * 0))) + ((PopFront * 0) + (PopFront * 1))) + ((PopBack * 0) + (PopBack * 1))) >= 1
2024-09-23 14:16:51.7469 TRACE Adding solver constraint for property this.head == this.Repr[default0] from Undefined to True: (((PushBack * 1) + (PushBack * 1)) + ((PushFront * 1) + (PushFront * 1))) >= 1
2024-09-23 14:16:51.7469 TRACE Adding solver constraint for property this.head == this.Repr[default0] from Undefined to True: (((PushBack * 1) + (PushBack * 0)) + ((PushFront * 1) + (PushFront * 0))) >= 1
2024-09-23 14:16:51.7469 TRACE Adding solver constraint for property default0 == |this.Repr| from False to True: (((((PushBack * 1) + (PushBack * 0)) + ((PushFront * 1) + (PushFront * 0))) + ((PopFront * 1) + (PopFront * 0))) + ((PopBack * 1) + (PopBack * 0))) >= 1
2024-09-23 14:16:51.7469 TRACE Adding solver constraint for property default0 == |this.Repr| from False to True: (((((PushBack * 1) + (PushBack * 0)) + ((PushFront * 1) + (PushFront * 0))) + ((PopFront * 1) + (PopFront * 0))) + ((PopBack * 1) + (PopBack * 0))) >= 1
2024-09-23 14:16:51.7469 TRACE Minimizing value: (((PushBack + PushFront) + PopFront) + PopBack)
2024-09-23 14:16:51.7469 DEBUG The integer programming gives the lower bound of 2 methods.
2024-09-23 14:16:51.7469 DEBUG In particular, need at least 2 calls to PushBack
2024-09-23 14:16:51.7469 DEBUG In particular, need at least -0 calls to PushFront
2024-09-23 14:16:51.7469 DEBUG In particular, need at least 0 calls to PopFront
2024-09-23 14:16:51.7469 DEBUG In particular, need at least -0 calls to PopBack
2024-09-23 14:16:51.7469 INFO The following method sequence is possible (heuristic=2): PopBack, PushBack, PushBack, PushBack, PushBack, PushBack, PushBack, PushBack
2024-09-23 14:16:51.7469 INFO New state is |this.Repr| > 0, |this.Repr| > 1, receiver.tail == receiver.head.next, this.tail == this.Repr[1], ¬(receiver.tail == null), receiver.head == receiver.tail.prev, this.head == this.Repr[0], ¬(receiver.head == null), receiver.IsValid.requires(), ¬(receiver == null), null == receiver.tail.next, null == receiver.head.prev, 2 == |this.Repr|, 56 == this.tail.value, 0 == this.head.value, true == this.IsValid()
2024-09-23 14:16:51.7469 INFO Expanding method sequence PushBack, PushBack, PushBack, PushBack, PushBack, PushBack, PushBack, PushBack -- estimated distance to start = 0, distance to end = 8
2024-09-23 14:16:51.7469 TRACE Verifying the body of the following method:
static method synthesized(formal_2_342_0: bool) returns (receiver: List) {assume true;
receiver := new List();
assert {:keepAssertion} !(!(receiver == null) && receiver.IsValid.requires() && true == receiver.IsValid() && null == receiver.head && null == receiver.tail && [] == receiver.Repr);}
2024-09-23 14:16:51.7469 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_2_342_0: bool) returns (receiver: List)
    {
      assume true;
      receiver := new List();
      assume {:formal} formal_2_342_0 == true;
      assert {:keepAssertion} !(!(receiver == null) && receiver.IsValid.requires() && formal_2_342_0 == receiver.IsValid() && null == receiver.head && null == receiver.tail && [] == receiver.Repr);
    }
2024-09-23 14:16:52.0689 TRACE Verifying the body of the following method:
static method synthesized(formal_2_342_0: bool) returns (receiver: List) {assume true;
receiver := new List();
assert {:keepAssertion} !(receiver == null) && receiver.IsValid.requires() && true == receiver.IsValid() && null == receiver.head && null == receiver.tail && [] == receiver.Repr;}
2024-09-23 14:16:52.0689 TRACE Verifying the body of the following method (literal):
 static method synthesized(formal_2_342_0: bool) returns (receiver: List)
    {
      assume true;
      receiver := new List();
      assume {:formal} formal_2_342_0 == true;
      assert {:keepAssertion} !(receiver == null) && receiver.IsValid.requires() && formal_2_342_0 == receiver.IsValid() && null == receiver.head && null == receiver.tail && [] == receiver.Repr;
    }
2024-09-23 14:16:52.3457 INFO Have found the following solution to a subproblem!
{
result := new List();
result.PushBack(0);
result.PushBack(1);
result.PushBack(2);
result.PushBack(4);
result.PushBack(5);
result.PushBack(6);
result.PushBack(7);
result.PushBack(8);
}
2024-09-23 14:16:52.3471 INFO Time spend on subproblem: 00:11:22.3053901
2024-09-23 14:16:52.3471 INFO Number of Regular queries to Dafny used to solve subproblem: 67 (00:00:39.5604104)
2024-09-23 14:16:52.3471 INFO Number of Simplify queries to Dafny used to solve subproblem: 32 (00:10:26.8360679)
2024-09-23 14:16:52.3471 INFO Number of Heuristic queries to Dafny used to solve subproblem: 48 (00:00:14.4460134)
2024-09-23 14:16:52.3471 INFO Have found the following solution!
static method solution() returns (result:List)
ensures Goal(result)
{
result := new List();
result.PushBack(0);
result.PushBack(1);
result.PushBack(2);
result.PushBack(4);
result.PushBack(5);
result.PushBack(6);
result.PushBack(7);
result.PushBack(8);
}
2024-09-23 14:16:52.3471 INFO Total time spend on synthesis: 00:11:22.6500050
2024-09-23 14:16:52.3471 INFO Total number of Regular queries to Dafny: 67 (00:00:39.5604104)
2024-09-23 14:16:52.3471 INFO Total number of Simplify queries to Dafny: 32 (00:10:26.8360679)
2024-09-23 14:16:52.3471 INFO Total number of Heuristic queries to Dafny: 48 (00:00:14.4460134)
